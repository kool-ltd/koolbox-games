<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chinese Poker Hand Arranger</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body { font-family: Arial, sans-serif; background: linear-gradient(to bottom, #1a202c, #2d3748); color: white; }
        .card { 
            width: 60px; height: 90px; border-radius: 5px; display: flex; align-items: center; justify-content: center; 
            font-size: 18px; margin: 5px; cursor: pointer; transition: transform 0.6s; transform-style: preserve-3d; 
            position: relative; background: white; border: 2px solid #4a5568;
        }
        .card-face { 
            position: absolute; width: 100%; height: 100%; backface-visibility: hidden; 
            display: flex; align-items: center; justify-content: center; border-radius: 5px;
        }
        .card-front { background: white; }
        .card-back { background: url('https://via.placeholder.com/60x90/4a5568/fff?text=') no-repeat center; transform: rotateY(180deg); }
        .card.flipped { transform: rotateY(180deg); }
        .card.selected { border: 3px solid #38a169; box-shadow: 0 0 10px #38a169; }
        .hearts, .diamonds { color: red; }
        .spades, .clubs { color: black; }
        .hand { margin-bottom: 20px; }
        .step { display: none; }
        .step.active { display: block; }
        .error { color: #f56565; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideIn { from { transform: translateX(-50px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .fade-in { animation: fadeIn 1s ease-in-out; }
        .slide-in { animation: slideIn 0.5s ease-out; }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4">
    <h1 class="text-3xl font-bold mb-6">Chinese Poker Hand Arranger</h1>

    <!-- Step 1: Choose Random or Pick -->
    <div id="step1" class="step active bg-gray-800 p-6 rounded-lg shadow-lg">
        <h2 class="text-xl mb-4">Step 1: Choose Your Cards</h2>
        <button onclick="goToRandom()" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded mr-4">Random 13 Cards</button>
        <button onclick="goToPick()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">Pick Cards</button>
    </div>

    <!-- Step 2 (Random): Show 13 Cards -->
    <div id="step2-random" class="step bg-gray-800 p-6 rounded-lg shadow-lg">
        <h2 class="text-xl mb-4">Step 2: Your 13 Random Cards</h2>
        <div id="randomCards" class="flex flex-wrap justify-center"></div>
        <div class="mt-4">
            <button onclick="goToArrange('step2-random')" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded mr-4">Arrange Hands</button>
            <button onclick="resetToStep1()" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">Back</button>
        </div>
    </div>

    <!-- Step 2 (Pick): Show 52 Cards in Grid -->
    <div id="step2-pick" class="step bg-gray-800 p-6 rounded-lg shadow-lg">
        <h2 class="text-xl mb-4">Step 2: Pick 13 Cards (<span id="cardCount">0</span>/13)</h2>
        <div class="grid grid-cols-4 gap-2">
            <div id="diamonds" class="flex flex-col"></div>
            <div id="clubs" class="flex flex-col"></div>
            <div id="hearts" class="flex flex-col"></div>
            <div id="spades" class="flex flex-col"></div>
        </div>
        <div class="mt-4">
            <button onclick="confirmPick()" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded mr-4" disabled id="confirmBtn">Confirm Selection</button>
            <button onclick="resetToStep1()" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">Back</button>
        </div>
        <p id="pickError" class="error hidden">Please select exactly 13 cards.</p>
    </div>

    <!-- Step 3: Show Optimal Arrangements with Animation -->
    <div id="step3" class="step bg-gray-800 p-6 rounded-lg shadow-lg">
        <h2 class="text-xl mb-4 slide-in">Step 3: Optimal Arrangements</h2>
        <div id="arrangements"></div>
        <div class="mt-4">
            <button onclick="goBackToStep2()" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded mr-4">Back</button>
            <button onclick="resetToStep1()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">Start Over</button>
        </div>
    </div>

    <script>
        const suits = { h: '♥', s: '♠', c: '♣', d: '♦' };
        const suitClasses = { h: 'hearts', s: 'spades', c: 'clubs', d: 'diamonds' };
        const ranks = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2'];
        const rankValues = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };

        let currentCards = [];
        let previousStep = '';

        // Step control
        function showStep(stepId) {
            document.querySelectorAll('.step').forEach(step => step.classList.remove('active'));
            document.getElementById(stepId).classList.add('active');
        }

        function goToRandom() {
            currentCards = shuffle(generateDeck()).slice(0, 13).sort(compareCards);
            displayCards(currentCards, 'randomCards');
            previousStep = 'step2-random';
            showStep('step2-random');
        }

        function goToPick() {
            currentCards = [];
            displayDeck();
            document.getElementById('cardCount').textContent = '0';
            document.getElementById('confirmBtn').disabled = true;
            document.getElementById('pickError').classList.add('hidden');
            previousStep = 'step2-pick';
            showStep('step2-pick');
        }

        function goToArrange(step) {
            previousStep = step;
            arrangeHands();
            showStep('step3');
        }

        function goBackToStep2() {
            showStep(previousStep);
        }

        function resetToStep1() {
            currentCards = [];
            previousStep = '';
            showStep('step1');
        }

        // Generate full deck
        function generateDeck() {
            const deck = [];
            for (let suit in suits) {
                for (let rank of ranks) {
                    deck.push(rank + suit);
                }
            }
            return deck;
        }

        // Shuffle array (Fisher-Yates)
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Compare cards for sorting (rank desc, then suit)
        function compareCards(a, b) {
            const rankA = rankValues[a.slice(0, -1)];
            const rankB = rankValues[b.slice(0, -1)];
            if (rankA !== rankB) return rankB - rankA;
            return a.charCodeAt(a.length - 1) - b.charCodeAt(b.length - 1);
        }

        // Display cards in a div
        function displayCards(cards, divId, flip = false) {
            const div = document.getElementById(divId).querySelector('.flex') || document.getElementById(divId);
            div.innerHTML = '';
            cards.forEach((card, i) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                if (flip) cardDiv.classList.add('flipped');
                cardDiv.innerHTML = `
                    <div class="card-face card-back"></div>
                    <div class="card-face card-front ${suitClasses[card.slice(-1)]}">
                        ${card.slice(0, -1) + suits[card.slice(-1)]}
                    </div>`;
                div.appendChild(cardDiv);
                if (flip) {
                    setTimeout(() => cardDiv.classList.remove('flipped'), 500 + i * 200);
                }
            });
        }

        // Display deck for picking with suit columns
        function displayDeck() {
            const deck = generateDeck();
            const bySuit = {
                d: deck.filter(c => c.endsWith('d')).sort(compareCards),
                c: deck.filter(c => c.endsWith('c')).sort(compareCards),
                h: deck.filter(c => c.endsWith('h')).sort(compareCards),
                s: deck.filter(c => c.endsWith('s')).sort(compareCards)
            };
            ['diamonds', 'clubs', 'hearts', 'spades'].forEach(suit => {
                const suitDiv = document.getElementById(suit);
                suitDiv.innerHTML = '';
                bySuit[suit[0]].forEach(card => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = `card ${suitClasses[card.slice(-1)]}`;
                    cardDiv.textContent = card.slice(0, -1) + suits[card.slice(-1)];
                    if (currentCards.includes(card)) cardDiv.classList.add('selected');
                    cardDiv.onclick = () => toggleCard(card, cardDiv);
                    suitDiv.appendChild(cardDiv);
                });
            });
        }

        // Toggle card selection
        function toggleCard(card, cardDiv) {
            if (currentCards.includes(card)) {
                currentCards = currentCards.filter(c => c !== card);
                cardDiv.classList.remove('selected');
            } else if (currentCards.length < 13) {
                currentCards.push(card);
                cardDiv.classList.add('selected');
            }
            document.getElementById('cardCount').textContent = currentCards.length;
            document.getElementById('confirmBtn').disabled = currentCards.length !== 13;
            document.getElementById('pickError').classList.toggle('hidden', currentCards.length <= 13);
        }

        // Confirm picked cards
        function confirmPick() {
            if (currentCards.length !== 13) {
                document.getElementById('pickError').classList.remove('hidden');
                return;
            }
            currentCards.sort(compareCards);
            goToArrange('step2-pick');
        }

        // Parse card: {rank, suit}
        function parseCard(cardStr) {
            return { rank: rankValues[cardStr.slice(0, -1)], suit: cardStr.slice(-1) };
        }

        // Evaluate 5-card poker hand
        function evaluate5(cards) {
            const parsed = cards.map(parseCard).sort((a, b) => b.rank - a.rank);
            const ranks = parsed.map(c => c.rank);
            const suits = parsed.map(c => c.suit);
            const counts = ranks.reduce((acc, r) => { acc[r] = (acc[r] || 0) + 1; return acc; }, {});
            const rankCounts = Object.values(counts).sort((a, b) => b - a);
            const uniqueRanks = Object.keys(counts).map(Number).sort((a, b) => b - a);
            const threeRank = Object.entries(counts).find(([r, c]) => c === 3)?.[0] || 0;
            const pairRank = Object.entries(counts).find(([r, c]) => c === 2)?.[0] || 0;

            let straight = false;
            let straightHigh = 0;
            const sortedRanks = [...new Set(ranks)].sort((a, b) => a - b);
            if (sortedRanks.length === 5 && (sortedRanks[4] - sortedRanks[0] === 4 || sortedRanks.join(',') === '2,3,4,5,14')) {
                straight = true;
                straightHigh = sortedRanks[4] === 14 && sortedRanks[0] === 2 ? 5 : sortedRanks[4];
            }

            const flush = new Set(suits).size === 1;
            const descMap = {
                8: 'Royal Flush', 7: 'Straight Flush', 6: 'Four of a Kind', 5: 'Full House',
                4: 'Flush', 3: 'Straight', 2: 'Three of a Kind', 1: 'Two Pair', 0: 'Pair', '-1': 'High Card'
            };

            if (flush && straight && straightHigh === 14 && ranks[0] === 14) return { type: 8, high: [14], desc: descMap[8] };
            if (flush && straight) return { type: 7, high: [straightHigh], desc: descMap[7] };
            if (rankCounts[0] === 4) return { type: 6, high: [uniqueRanks[0]], desc: descMap[6] };
            if (rankCounts[0] === 3 && rankCounts[1] === 2) return { type: 5, high: [parseInt(threeRank), parseInt(pairRank)], desc: descMap[5] };
            if (flush) return { type: 4, high: ranks, desc: descMap[4] };
            if (straight) return { type: 3, high: [straightHigh], desc: descMap[3] };
            if (rankCounts[0] === 3) return { type: 2, high: [uniqueRanks[0]], desc: descMap[2] };
            if (rankCounts[0] === 2 && rankCounts[1] === 2) return { type: 1, high: [uniqueRanks[0], uniqueRanks[1]], desc: descMap[1] };
            if (rankCounts[0] === 2) return { type: 0, high: [uniqueRanks[0]], desc: descMap[0] };
            return { type: -1, high: ranks, desc: descMap['-1'] };
        }

        // Evaluate 3-card hand
        function evaluate3(cards) {
            const parsed = cards.map(parseCard).sort((a, b) => b.rank - a.rank);
            const ranks = parsed.map(c => c.rank);
            const counts = ranks.reduce((acc, r) => { acc[r] = (acc[r] || 0) + 1; return acc; }, {});
            const rankCounts = Object.values(counts).sort((a, b) => b - a);
            const uniqueRanks = Object.keys(counts).map(Number).sort((a, b) => b - a);

            if (rankCounts[0] === 3) return { type: 2, high: uniqueRanks, desc: 'Three of a Kind' };
            if (rankCounts[0] === 2) return { type: 1, high: [uniqueRanks[0]], desc: 'Pair' };
            return { type: 0, high: uniqueRanks, desc: 'High Card' };
        }

        // Get royalty for a hand
        function getRoyalty(eval, row) {
            if (row === 'front') {
                if (eval.type === 1) return Math.max(0, eval.high[0] - 5); // Pair 6=1 to A=9
                if (eval.type === 2) return eval.high[0] + 8; // Trips 2=10 to A=22
                return 0;
            } else {
                const mul = row === 'middle' ? 2 : 1;
                if (eval.type === 8) return 25 * mul;
                if (eval.type === 7) return 15 * mul;
                if (eval.type === 6) return 10 * mul;
                if (eval.type === 5) return 6 * mul;
                if (eval.type === 4) return 4 * mul;
                if (eval.type === 3) return 2 * mul;
                return 0;
            }
        }

        // Get ranking key for accurate comparison
        function getRankingKey(eval, cards, is3card = false) {
            let type = eval.type;
            if (is3card) {
                if (type === 0) type = -1; // high
                if (type === 1) type = 0; // pair
                // trips 2 remains
            }
            const parsed = cards.map(parseCard);
            let ranks = parsed.map(c => c.rank).sort((a, b) => b - a);
            let key = [type];
            if (type <= -1 || type === 4) { // high or flush
                key = key.concat(ranks);
            } else if (type === 0) { // pair
                const pairRank = eval.high[0];
                const kickers = ranks.filter(r => r !== pairRank).sort((a, b) => b - a);
                key = key.concat([pairRank, ...kickers]);
            } else if (type === 1) { // two pair
                const highPair = eval.high[0], lowPair = eval.high[1];
                const kicker = ranks.find(r => r !== highPair && r !== lowPair);
                key = key.concat([highPair, lowPair, kicker]);
            } else if (type === 2) { // trips
                const tripsRank = eval.high[0];
                const kickers = ranks.filter(r => r !== tripsRank).sort((a, b) => b - a);
                key = key.concat([tripsRank, ...kickers]);
            } else if (type === 3 || type === 7) { // straight or sf
                key = key.concat(eval.high);
            } else if (type === 5) { // fh
                key = key.concat(eval.high); // three, pair
            } else if (type === 6) { // quads
                const quadRank = eval.high[0];
                const kicker = ranks.find(r => r !== quadRank);
                key = key.concat([quadRank, kicker]);
            } else if (type === 8) { // royal
                key = key.concat([14]);
            }
            return key;
        }

        // Compare two hands accurately (returns >0 if A > B, <0 if A < B, 0 if tie)
        function compareHands(evalA, cardsA, is3A, evalB, cardsB, is3B) {
            const keyA = getRankingKey(evalA, cardsA, is3A);
            const keyB = getRankingKey(evalB, cardsB, is3B);
            const len = Math.max(keyA.length, keyB.length);
            const paddedA = [...keyA, ...new Array(len - keyA.length).fill(0)];
            const paddedB = [...keyB, ...new Array(len - keyB.length).fill(0)];
            for (let i = 0; i < len; i++) {
                if (paddedA[i] !== paddedB[i]) return paddedA[i] - paddedB[i];
            }
            return 0;
        }

        // Generate combinations
        function combinations(arr, k) {
            const res = [];
            function comb(start, combo) {
                if (combo.length === k) {
                    res.push([...combo]);
                    return;
                }
                for (let i = start; i < arr.length; i++) {
                    combo.push(arr[i]);
                    comb(i + 1, combo);
                    combo.pop();
                }
            }
            comb(0, []);
            return res;
        }

        // Arrange hands
        function arrangeHands() {
            const allCards = [...currentCards];
            const validArrangements = [];

            // Generate all possible back hands
            const backs = combinations(allCards, 5);
            for (let back of backs) {
                const evalB = evaluate5(back);
                const rem1 = allCards.filter(c => !back.includes(c));
                // Generate all possible middle hands
                const middles = combinations(rem1, 5);
                for (let middle of middles) {
                    const evalM = evaluate5(middle);
                    const front = rem1.filter(c => !middle.includes(c));
                    const evalF = evaluate3(front);

                    // Check no foul
                    if (compareHands(evalB, back, false, evalM, middle, false) <= 0) continue;
                    if (compareHands(evalM, middle, false, evalF, front, true) <= 0) continue;

                    const royaltyB = getRoyalty(evalB, 'back');
                    const royaltyM = getRoyalty(evalM, 'middle');
                    const royaltyF = getRoyalty(evalF, 'front');
                    const totalRoyalty = royaltyB + royaltyM + royaltyF;

                    // Score prioritizes royalties, then types
                    const typeScore = 8 * evalB.type + 4 * evalM.type + evalF.type;
                    const score = totalRoyalty * 100 + typeScore;

                    // Secondary: front value (sum high)
                    const frontValue = evalF.high.reduce((sum, val) => sum + val, 0);

                    // Tertiary: middle value (sum high)
                    const middleValue = evalM.high.reduce((sum, val) => sum + val, 0);

                    const pattern = `${evalF.desc} | ${evalM.desc} | ${evalB.desc}`;

                    validArrangements.push({
                        score,
                        frontValue,
                        middleValue,
                        front: front.sort(compareCards),
                        middle: middle.sort(compareCards),
                        back: back.sort(compareCards),
                        evals: { f: evalF, m: evalM, b: evalB },
                        royalties: { f: royaltyF, m: royaltyM, b: royaltyB, total: totalRoyalty },
                        pattern
                    });
                }
            }

            if (validArrangements.length === 0) {
                document.getElementById('arrangements').innerHTML = '<p class="error">No valid arrangement found without fouling.</p>';
                return;
            }

            // Sort by score desc, then frontValue desc, then middleValue desc
            validArrangements.sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                if (b.frontValue !== a.frontValue) return b.frontValue - a.frontValue;
                return b.middleValue - a.middleValue;
            });

            // Select up to 2 with unique patterns
            const bestArrangements = [];
            const seenPatterns = new Set();
            for (let arr of validArrangements) {
                if (!seenPatterns.has(arr.pattern)) {
                    seenPatterns.add(arr.pattern);
                    bestArrangements.push(arr);
                    if (bestArrangements.length === 2) break;
                }
            }

            const arrangementsDiv = document.getElementById('arrangements');
            arrangementsDiv.innerHTML = '';
            bestArrangements.forEach((arr, index) => {
                const arrangementDiv = document.createElement('div');
                arrangementDiv.className = 'mb-6';
                arrangementDiv.innerHTML = `
                    <h3 class="text-lg font-bold mb-2">Arrangement ${index + 1} (Total Royalty: ${arr.royalties.total})</h3>
                    <div id="frontHand${index}" class="hand"><strong>Front (3 cards - ${arr.evals.f.desc}, Royalty: ${arr.royalties.f}):</strong><br><div class="flex flex-wrap"></div></div>
                    <div id="middleHand${index}" class="hand"><strong>Middle (5 cards - ${arr.evals.m.desc}, Royalty: ${arr.royalties.m}):</strong><br><div class="flex flex-wrap"></div></div>
                    <div id="backHand${index}" class="hand"><strong>Back (5 cards - ${arr.evals.b.desc}, Royalty: ${arr.royalties.b}):</strong><br><div class="flex flex-wrap"></div></div>
                `;
                arrangementsDiv.appendChild(arrangementDiv);
                displayCards(arr.front, `frontHand${index}`, true);
                displayCards(arr.middle, `middleHand${index}`, true);
                displayCards(arr.back, `backHand${index}`, true);
            });
        }
    </script>
</body>
</html>
